# Redis开发与运维·阅读笔记

《Redis开发与运维》的阅读笔记。

## 第1章 初识Redis

本章主要讲述了Redis的特性和一些使用场景，告诉我们怎么用好Redis，
除此之外还包括Redis的安装、配置、启动、关闭等操作，以及Redis的版本迭代等内容。

## 第2章 API的理解和使用

### 2.1 预备

在正式学习5种数据结构之前，最好先了解一下Redis的一些全局命令、数据结构和内部编码及单线程命令处理机制。

#### 2.1.1 全局命令

相关命令如下所示：

```
127.0.0.1:6379> SET c hiredis
127.0.0.1:6379> SET java jedis
127.0.0.1:6379> SET php phpredis

# 查看所有键
127.0.0.1:6379> KEYS *

# 插入一个类型为列表的键值对（值由多个元素组成）
127.0.0.1:6379> RPUSH mylist 0 1 2 3 4

# 查看键总数
127.0.0.1:6379> DBSIZE

# 确认键是否存在
127.0.0.1:6379> EXISTS c
127.0.0.1:6379> EXISTS cpp

# 删除键
127.0.0.1:6379> DEL c

# 设置键的过期时间
127.0.0.1:6379> EXPIRE java 5
# 查看键的剩余过期时间
127.0.0.1:6379> TTL java

# 查看键的数据结构类型
127.0.0.1:6379> TYPE php
```

#### 2.1.2 数据结构和内部编码

TYPE 命令实际返回的就是当前键的数据结构类型，它们分别是：
string（字符串）、hash（哈希）、list（列表）、set（集合）及zset（有序集合）。

实际上每种数据结构都有自己底层的内部编码实现，而且是多种实现，
Redis 会在合适的场景选择合适的内部编码。

每种数据结构都有两种以上的内部编码实现，例如 list 数据结构，
它包含了 linkedlist 和 ziplist 两种内部编码。
同时某些内部编码，例如 ziplist，可以作为多种外部数据结构的内部实现。

可以通过 OBJECT ENCODING 命令查询内部编码：

```
127.0.0.1:6379> OBJECT ENCODING php
127.0.0.1:6379> OBJECT ENCODING mylist
```

Redis 这样设计有两个好处：

1. 可以改进内部编码，而对外的数据结构和命令没有影响，这样一旦开发出更优秀的内部编码，无需改动外部数据结构和命令。
   例如 Redis 3.2 提供了 quicklist，结合了 ziplist 和 linkedlist 两者的优势，
   为列表类型提供了一种更为优秀的内部编码实现，但外部用户基本感知不到。

2. 多种内部编码实现可以在不同场景下发挥各自的优势，例如 ziplist 比较节省内存，
   但在列表元素比较多的情况下，性能会有所下降，这时 Redis 会根据配置选项将列表类型的内部实现转换为 linkedlist。

#### 2.1.3 单线程架构

Redis 是单线程处理命令的，所以一条命令从客户端到达服务端不会立刻被执行，所有命令都会进入一个队列中，然后逐个被执行。

通常来讲，单线程的处理能力要比多线程差，那为什么 Redis 使用单线程模型会达到每秒万级别的处理能力呢？可以将其归结为三点：

1. 纯内存访问，Redis 将所有数据放在内存中，内存的响应时长大约为100ns，这是 Redis 达到每秒万级别访问的重要基础。

2. 非阻塞I/O，Redis 使用 epoll 作为I/O多路复用技术的实现，
   再加上 Redis 自身的事件处理模型将 epoll 中的连接、读写、关闭都转换为事件，不在网络I/O上浪费过多的时间。

3. 单线程避免了线程切换和竞态产生的消耗。

同时单线程也带来了几个好处：

1. 单线程可以简化数据结构和算法的实现，实现并发数据结构不但困难而且开发测试比较麻烦。

2. 单线程避免了线程切换和竞态产生的消耗，对于服务端开发来说，锁和线程切换通常是性能杀手。

但是单线程会有一个问题：对于每个命令的执行时间是有要求的。
如果某个命令执行过久，会造成其他命令的阻塞，
这对 Redis 这种高性能的服务来说是致命的，所以 Redis 是面向快速执行场景的数据库。

### 2.2 字符串

#### 2.2.1 命令

相关命令如下所示：

```
# 3s后过期
127.0.0.1:6379> SETEX epoll 3 1

# 只有键不存在才可以设置成功，用于添加
127.0.0.1:6379> SETNX iocp 0

127.0.0.1:6379> GET iocp
```

以 setnx 命令为例，由于 Redis 的单线程命令处理机制，如果有多个客户端同时执行`SETNX key value`，
只有一个客户端能设置成功，setnx 可以作为分布式锁的一种实现方案，
Redis 官方给出了[使用 setnx 实现分布式锁](https://redis.io/topics/distlock)的方法。

```
127.0.0.1:6379> MSET a 1 b 2 c 3 d 4
127.0.0.1:6379> MGET a b c d
```

学会批量操作，有助于提高业务处理效率，但要注意的是每次批量操作所发送的命令数并不是无节制的，
如果数量过多可能会造成 Redis 阻塞或者网络拥塞。

```
# 自增/自减1
127.0.0.1:6379> INCR counter
127.0.0.1:6379> DECR counter

# 自增/自减2
127.0.0.1:6379> INCRBY counter 2
127.0.0.1:6379> DECRBY counter 2
```

很多存储系统和编程语言内部使用 CAS 机制实现计数功能，会有一定的 CPU 开销，
但在 Redis 中完全不存在这个问题，因为 Redis 是单线程架构，任何命令到了 Redis 服务端都要按序执行。

```
127.0.0.1:6379> SET s Hello

127.0.0.1:6379> APPEND s ' World!'

127.0.0.1:6379> STRLEN s

# 设置并返回原值
127.0.0.1:6379> GETSET s 'Hello MySQL!'
127.0.0.1:6379> GETSET s 'Hello Redis!'

# 设置指定位置的字符
127.0.0.1:6379> SETRANGE s 6 J

# 获取'Redis'子串
127.0.0.1:6379> GETRANGE s 6 10
```

#### 2.2.2 内部编码

如下所示。

```
127.0.0.1:6379> SET s 123456789
127.0.0.1:6379> OBJECT ENCODING s # "int"

# <= 44bytes
127.0.0.1:6379> SET s c
127.0.0.1:6379> OBJECT ENCODING s # "embstr"

# > 44bytes
127.0.0.1:6379> SET s '123456789012345678901234567890123456789012345'
127.0.0.1:6379> OBJECT ENCODING s # "raw"
```

#### 2.2.3 典型使用场景

主要有以下几个使用场景：

1. 缓存功能
2. 计数（比如计算视频播放数）
3. 共享Session
4. 限速（比如限制用户每分钟获取验证码的频率）

### 2.3 哈希



### 2.4 列表



### 2.5 集合



### 2.6 有序集合



### 2.7 键管理


